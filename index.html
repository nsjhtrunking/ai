<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
<title>Leaf / Tree / Fall Designer 3D｜v0.7.2 (online)</title>
<style>
  :root{ --bg:#0f172a; --panel:#0b1220; --ink:#e2e8f0; --muted:#94a3b8; --brand:#22c55e; --accent:#34d399; --danger:#ef4444 }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,"Noto Sans TC",Segoe UI,Roboto}
  .wrap{display:grid;grid-template-columns:1fr 380px;height:100%}
  #stage{position:relative;background:#0b1020;height:100%;min-height:360px}
  canvas{display:block;width:100%;height:100%}
  .panel{height:100%;overflow:auto;background:linear-gradient(180deg,var(--panel),#0a0f1b 55%);border-left:1px solid #1f2937;padding:14px 14px 120px}
  .h{display:flex;align-items:center;gap:10px;margin:2px 0 8px}
  .h .dot{width:10px;height:10px;border-radius:999px;background:var(--brand);box-shadow:0 0 16px var(--brand)}
  h1{font-size:18px;margin:0 0 2px}
  p.sub{margin:0;color:var(--muted);font-size:12px}
  .g{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center;margin:10px 0}
  .row{margin:8px 0}
  .lbl{font-size:12px;color:var(--muted);letter-spacing:.2px}
  .val{font-variant-numeric:tabular-nums}
  input[type=range]{width:100%}
  select{width:100%;padding:8px;border-radius:10px;background:#0e1729;border:1px solid #243246;color:var(--ink)}
  .btns{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:12px}
  button{padding:10px 12px;border:1px solid #263142;background:#0e1729;color:#e2e8f0;border-radius:12px;cursor:pointer}
  button:hover{border-color:#334155}
  button.primary{background:linear-gradient(180deg,#0e2d1b,#0b1f14);border-color:#1d3b29}
  button.primary:hover{border-color:#27533a}
  .small{font-size:12px;color:var(--muted);margin-top:8px;line-height:1.4}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .card{border:1px solid #1f2937;border-radius:12px;padding:10px;text-align:center}
  .card b{display:block;font-size:16px}
  .card span{display:block;color:#94a3b8;font-size:11px}
  .sep{height:1px;background:#1e293b;margin:12px 0}
  #diag{position:fixed;right:10px;top:10px;background:#0a1120e6;border:1px solid #1e293b;border-radius:10px;padding:8px 10px;color:#cbd5e1;font-size:12px;max-width:44ch;z-index:9999;display:none}
  #diag.show{display:block}
  .warn{color:#fbbf24}
</style>
</head>
<body>
<div class="wrap">
  <div id="stage"></div>
  <aside class="panel">
    <div class="h"><span class="dot"></span><div><h1>Leaf / Tree / Fall Designer 3D</h1><p class="sub">v0.7.2｜三場景｜支援 100,000 葉、分枝層數最高 100（安全上限）</p></div></div>

    <div class="btns" style="grid-template-columns:repeat(3,1fr);margin:8px 0 10px">
      <button id="btnScene1" class="primary">場景一：葉片</button>
      <button id="btnScene2">場景二：樹</button>
      <button id="btnScene3">場景三：落葉</button>
    </div>

    <div id="sceneLeaf">
      <div class="kpi">
        <div class="card"><b id="kpiVerts">—</b><span>頂點</span></div>
        <div class="card"><b id="kpiFaces">—</b><span>面數</span></div>
        <div class="card"><b id="kpiArea">—</b><span>估算面積 (cm²)</span></div>
      </div>
      <div class="sep"></div>
      <div class="row g"><label class="lbl">長度 (cm)</label><span class="val" id="valLen"></span></div>
      <input id="len" type="range" min="4" max="40" step="0.1" value="16.8" />
      <div class="row g"><label class="lbl">寬度比例</label><span class="val" id="valWidth"></span></div>
      <input id="width" type="range" min="0.15" max="0.7" step="0.01" value="0.37" />
      <div class="row g"><label class="lbl">尖端銳利度</label><span class="val" id="valTip"></span></div>
      <input id="tip" type="range" min="0.2" max="2.5" step="0.01" value="0.58" />
      <div class="row g"><label class="lbl">基部圓潤度</label><span class="val" id="valBase"></span></div>
      <input id="base" type="range" min="0.2" max="2.5" step="0.01" value="2.5" />
      <div class="row g"><label class="lbl">捲曲度（橫向）</label><span class="val" id="valCurl"></span></div>
      <input id="curl" type="range" min="0" max="1.2" step="0.01" value="0" />
      <div class="row g"><label class="lbl">扭轉度（縱向）</label><span class="val" id="valTwist"></span></div>
      <input id="twist" type="range" min="0" max="1.5" step="0.01" value="0.2" />
      <div class="row g"><label class="lbl">上拱彎曲</label><span class="val" id="valBend"></span></div>
      <input id="bend" type="range" min="-0.8" max="1.2" step="0.01" value="-0.52" />
      <div class="row g"><label class="lbl">主脈厚度（視覺）</label><span class="val" id="valRib"></span></div>
      <input id="rib" type="range" min="0" max="0.6" step="0.01" value="0.28" />
      <div class="row g"><label class="lbl">鋸齒幅度</label><span class="val" id="valSerrA"></span></div>
      <input id="serrA" type="range" min="0" max="0.25" step="0.005" value="0.095" />
      <div class="row g"><label class="lbl">鋸齒密度</label><span class="val" id="valSerrF"></span></div>
      <input id="serrF" type="range" min="0" max="30" step="1" value="7" />
      <div class="row"><label class="lbl"><input id="double" type="checkbox" checked> 雙面曲面</label></div>
      <div class="row"><label class="lbl"><input id="stem" type="checkbox" unchecked> 顯示葉柄</label></div>
      <div class="btns" style="grid-template-columns:repeat(2,1fr)">
        <button id="reset">重設</button>
        <button id="randomize">隨機</button>
      </div>
      <div class="sep"></div>
      <button id="goTree" class="primary" title="把目前葉片帶到下一個場景">→ 送到樹場景</button>
      <p class="small">操作：拖曳旋轉、滾輪縮放、右鍵平移；手機可雙指縮放、兩指拖曳平移。</p>
    </div>

    <div id="sceneTree" style="display:none">
      <div class="row g"><label class="lbl">樹高 (m)</label><span class="val" id="valTreeH"></span></div>
      <input id="treeH" type="range" min="2" max="20" step="0.1" value="2.5" />
      <div class="row g"><label class="lbl">樹冠半徑 (m)</label><span class="val" id="valCrownR"></span></div>
      <input id="crownR" type="range" min="1" max="12" step="0.1" value="10" />
      <div class="row g"><label class="lbl">分枝層數（1–100）</label><span class="val" id="valLevels"></span></div>
      <input id="levels" type="range" min="1" max="30" step="1" value="10" />
      <div class="row g"><label class="lbl">分枝張角 (°)</label><span class="val" id="valSpread"></span></div>
      <input id="spread" type="range" min="10" max="120" step="1" value="65" />
      <div class="row g"><label class="lbl">樹幹傾斜 (°)</label><span class="val" id="valLean"></span></div>
      <input id="lean" type="range" min="-8" max="8" step="1" value="2" />
      <div class="row g"><label class="lbl">葉片數量 <span class="warn">(高於 40k 需強效顯卡)</span></label><span class="val" id="valLeafCount"></span></div>
      <input id="leafCount" type="range" min="50" max="100000" step="50" value="11200" />
      <div class="row g"><label class="lbl">樹型</label><span class="val" id="valShape"></span></div>
      <select id="shape">
        <option value="sphere" selected>球形（自然）</option>
        <option value="cone">圓錐</option>
        <option value="vase">花瓶</option>
      </select>
      <div class="btns" style="grid-template-columns:repeat(3,1fr);margin-top:10px">
        <button id="btnBuildTree" class="primary">生成樹</button>
        <button id="btnClearTree">清除樹</button>
        <button id="btnFit">視角置中</button>
      </div>
      <p class="small">說明：分枝層數採「迭代廣度優先 + 安全上限」，避免指數爆炸。可同時搭配葉片數量 100k。</p>
    </div>

    <div id="sceneFall" style="display:none">
      <div class="row g"><label class="lbl">季節時間倍率</label><span class="val" id="valSeasonRate"></span></div>
      <input id="seasonRate" type="range" min="0.1" max="4" step="0.1" value="1.0"/>
      <div class="row g"><label class="lbl">落葉速度倍率</label><span class="val" id="valFallRate"></span></div>
      <input id="fallRate" type="range" min="0.5" max="2" step="0.1" value="1.0"/>
      <div class="row g"><label class="lbl">風強度</label><span class="val" id="valWind"></span></div>
      <input id="windAmp" type="range" min="0" max="8" step="0.1" value="3.0"/>
      <div class="row g"><label class="lbl">亂流（類 Perlin）</label><span class="val" id="valTurb"></span></div>
      <input id="turb" type="range" min="0" max="3" step="0.05" value="1.2"/>
      <div class="row g"><label class="lbl">再長回速度</label><span class="val" id="valRegrow"></span></div>
      <input id="regrow" type="range" min="0.1" max="3" step="0.1" value="1.0"/>
      <div class="row g"><label class="lbl">每幀模擬上限（葉片數）</label><span class="val" id="valMaxActive"></span></div>
      <input id="maxActive" type="range" min="200" max="4000" step="100" value="1200"/>
      <div class="btns" style="margin-top:10px">
        <button id="btnStartFall" class="primary">開始落葉</button>
        <button id="btnStopFall">停止</button>
        <button id="btnResetFall">重置季節</button>
      </div>
      <p class="small">說明：落葉「逐片」脫離；100k 模式僅對上限數量的「正在飄落」葉片做物理更新。</p>
    </div>
  </aside>
</div>

<div id="diag"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js?module';
import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js?module';

const diagEl = document.getElementById('diag');
function diag(msg, ok=false){ diagEl.classList.add('show'); diagEl.innerHTML = (ok?'<b style="color:#22c55e">OK</b> ':'<b style="color:#f97316">LOG</b> ') + String(msg); }
window.addEventListener('error', e=>{ diag(`錯誤：${e.message}`); });
window.addEventListener('unhandledrejection', e=>{ diag(`Promise 拋錯：${e.reason}`); });

// --- THREE setup ---
const stage = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setClearColor(0x0b1020, 1);
stage.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 5000);
camera.position.set(3.2, 2.6, 3.6);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.06; controls.enablePan = true;
controls.target.set(0,1.5,0);

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dir1 = new THREE.DirectionalLight(0xffffff, 1.0); dir1.position.set(4,6,4); scene.add(dir1);
const dir2 = new THREE.DirectionalLight(0xffffff, 0.6); dir2.position.set(-6,2,-6); scene.add(dir2);
const hemi = new THREE.HemisphereLight(0x8ecae6, 0x0b1020, 0.35); scene.add(hemi);
const grid = new THREE.GridHelper(120, 60, 0x1f2937, 0x142234); grid.position.y = 0; scene.add(grid);

const matLeaf = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.9, metalness:0.02, side:THREE.DoubleSide, vertexColors:true});
const matStem = new THREE.MeshStandardMaterial({color:0x10b981, roughness:0.95});
const groundMat = new THREE.MeshStandardMaterial({color:0x2b3344, metalness:0.0, roughness:0.95});

function qs(sel){return document.querySelector(sel)}
const ui = {
  len: qs('#len'), width: qs('#width'), tip: qs('#tip'), base: qs('#base'), curl: qs('#curl'), twist: qs('#twist'), bend: qs('#bend'), rib: qs('#rib'), serrA: qs('#serrA'), serrF: qs('#serrF'),
  double: qs('#double'), stem: qs('#stem'), reset: qs('#reset'), rnd: qs('#randomize'), goTree: qs('#goTree')
};
const label = { len: qs('#valLen'), width: qs('#valWidth'), tip: qs('#valTip'), base: qs('#valBase'), curl: qs('#valCurl'), twist: qs('#valTwist'), bend: qs('#valBend'), rib: qs('#valRib'), serrA: qs('#valSerrA'), serrF: qs('#valSerrF') };
const KPIV = qs('#kpiVerts'), KPIF = qs('#kpiFaces'), KPIA = qs('#kpiArea');

const P = {
  len: parseFloat(ui.len.value),
  width: parseFloat(ui.width.value),
  tip: parseFloat(ui.tip.value || 1.1),
  base: parseFloat(ui.base.value || 1.2),
  curl: parseFloat(ui.curl.value),
  twist: parseFloat(ui.twist.value),
  bend: parseFloat(ui.bend.value),
  rib: parseFloat(ui.rib.value),
  serrA: parseFloat(ui.serrA.value),
  serrF: parseFloat(ui.serrF.value),
  double: qs('#double').checked,
  stem: qs('#stem').checked,
  resU: 64, resV: 28
};
let leafMesh=null, stemMesh=null;
let treeGroup = null;
let leavesInst = null;
let ground = null, groundHeights = null;
let fallRunning = false; let fallClock = 0; let firstFit = true;

// Fall state
let leafVel, leafAngVel, leafPhase, leafState;
let fallingList = [];
let windBaseDir = 0, windTime = 0;

function smoothstep(e0,e1,x){const t=Math.max(0,Math.min(1,(x-e0)/(e1-e0))); return t*t*(3-2*t)}
function rotY(ang,x,y,z){ const c=Math.cos(ang), s=Math.sin(ang); return {x:c*x + s*z, y, z:-s*x + c*z}; }
function rotX(ang,x,y,z){ const c=Math.cos(ang), s=Math.sin(ang); return {x, y:c*y - s*z, z:s*y + c*z}; }
function lerp(a,b,t){return a+(b-a)*t}

// --- scene switching ---
const sceneLeaf = document.getElementById('sceneLeaf');
const sceneTree = document.getElementById('sceneTree');
const sceneFall = document.getElementById('sceneFall');
const btnScene1 = document.getElementById('btnScene1');
const btnScene2 = document.getElementById('btnScene2');
const btnScene3 = document.getElementById('btnScene3');
btnScene1.addEventListener('click', ()=> showScene(1));
btnScene2.addEventListener('click', ()=> { showScene(2); buildTree(); });
btnScene3.addEventListener('click', ()=> { showScene(3); prepareFall(); });
function showScene(n){ sceneLeaf.style.display = (n===1)?'block':'none'; sceneTree.style.display = (n===2)?'block':'none'; sceneFall.style.display = (n===3)?'block':'none'; }

// --- leaf geometry ---
function buildLeaf(){
  const geo = buildLeafGeometry(P);
  if(!leafMesh){ leafMesh = new THREE.Mesh(geo, matLeaf); scene.add(leafMesh); }
  else { leafMesh.geometry.dispose(); leafMesh.geometry = geo; }
  if(P.stem){
    const st = buildStemGeometry(P);
    if(!stemMesh){ stemMesh = new THREE.Mesh(st, matStem); scene.add(stemMesh); }
    else { stemMesh.geometry.dispose(); stemMesh.geometry = st; }
  } else if(stemMesh){ scene.remove(stemMesh); stemMesh.geometry.dispose(); stemMesh=null; }
  KPIV.textContent = geo.attributes.position.count;
  KPIF.textContent = geo.index ? (geo.index.count/3) : (geo.attributes.position.count/3);
  KPIA.textContent = (estimateArea(geo)).toFixed(2);
  if(firstFit){ fitCameraTo(leafMesh, 1.8); firstFit = false; }
}

function buildLeafGeometry(p){
  const L = p.len/100;
  const Wmax = (p.len * p.width)/100;
  const resU = p.resU, resV = p.resV;
  const pos = new Float32Array((resU+1)*(resV+1)*3);
  const col = new Float32Array((resU+1)*(resV+1)*3);
  const idx=[]; let ptr=0, cptr=0;
  for(let iu=0; iu<=resU; iu++){
    const u = iu/resU;
    const s = Math.sin(Math.PI * Math.min(1, Math.max(0,u)));
    const tipPow=p.tip, basePow=p.base;
    const tipFactor=Math.pow(1-u,tipPow);
    const baseFactor=Math.pow(u,basePow);
    let halfW = Wmax * s * (0.65 + 0.35*(1 - tipFactor) * (0.7 + 0.3*baseFactor));
    const serrAmp=(p.serrA)*Wmax;
    for(let iv=0; iv<=resV; iv++){
      const vv=iv/resV; const v=vv*2-1;
      const edge = smoothstep(0.6,1.0,Math.abs(v));
      const serr = serrAmp * Math.sin(2*Math.PI * p.serrF * u) * edge * Math.sign(v);
      let x=(u - 0.1)*L;
      let y=(v)*(halfW + serr);
      let z=0;
      const mid=1 - Math.min(1, Math.abs(v)/0.8);
      z += (p.rib/100) * Math.pow(mid,2);
      const curlAngle=p.curl*(u)*0.8*Math.PI*(Math.abs(v));
      ({x,y,z}=rotY(Math.sign(v)*curlAngle,x,y,z));
      const twA=p.twist*Math.PI*u; ({x,y,z}=rotX(twA,x,y,z));
      z += (p.bend/100) * ( -4*Math.pow(u-0.5,2) + 1 );
      pos[ptr++]=x; pos[ptr++]=y; pos[ptr++]=z;
      const c = new THREE.Color().setHSL(0.45 - 0.1*u, 0.6, 0.5+0.2*(1-u));
      col[cptr++]=c.r; col[cptr++]=c.g; col[cptr++]=c.b;
    }
  }
  for(let iu=0; iu<resU; iu++) for(let iv=0; iv<resV; iv++){
    const a=(resV+1)*iu+iv; const b=a+(resV+1); const c=b+1; const d=a+1; idx.push(a,b,d, b,c,d);
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));
  geo.setIndex(idx);
  geo.computeVertexNormals();
  return geo;
}
function buildStemGeometry(p){ const len=Math.max(0.08, Math.min(0.2, p.len/100 * 0.15)); const r=Math.max(0.002, Math.min(0.01, p.len/100 * 0.015)); const geo=new THREE.CapsuleGeometry(r, len, 4, 8); geo.rotateX(Math.PI/2); geo.translate(-0.06,0,0); return geo; }

function estimateArea(geo){ const pos=geo.attributes.position, index=geo.index; let area=0; const a=new THREE.Vector3(),b=new THREE.Vector3(),c=new THREE.Vector3(); if(!index){ for(let i=0;i<pos.count;i+=9){ a.set(pos.array[i],pos.array[i+1],pos.array[i+2]); b.set(pos.array[i+3],pos.array[i+4],pos.array[i+5]); c.set(pos.array[i+6],pos.array[i+7],pos.array[i+8]); area+=triangleArea(a,b,c);} } else { for(let i=0;i<index.count;i+=3){ a.fromBufferAttribute(pos,index.getX(i)); b.fromBufferAttribute(pos,index.getX(i+1)); c.fromBufferAttribute(pos,index.getX(i+2)); area+=triangleArea(a,b,c);} } return area*10000; }
function triangleArea(a,b,c){ const ab=new THREE.Vector3().subVectors(b,a); const ac=new THREE.Vector3().subVectors(c,a); return ab.cross(ac).length()/2; }

function syncLeafLabels(){ label.len.textContent=P.len.toFixed(1)+' cm'; label.width.textContent=P.width.toFixed(2); label.tip.textContent=P.tip.toFixed(2); label.base.textContent=P.base.toFixed(2); label.curl.textContent=P.curl.toFixed(2); label.twist.textContent=P.twist.toFixed(2); label.bend.textContent=P.bend.toFixed(2); label.rib.textContent=P.rib.toFixed(2)+' cm'; label.serrA.textContent=P.serrA.toFixed(3); label.serrF.textContent=String(P.serrF|0); }
['len','width','tip','base','curl','twist','bend','rib','serrA','serrF'].forEach(k=> ui[k].addEventListener('input', ()=>{ P[k]=parseFloat(ui[k].value); syncLeafLabels(); buildLeaf(); }));
qs('#double').addEventListener('change', e=>{ P.double=e.target.checked; matLeaf.side=P.double?THREE.DoubleSide:THREE.FrontSide; buildLeaf(); });
qs('#stem').addEventListener('change', e=>{ P.stem=e.target.checked; buildLeaf(); });
qs('#reset').addEventListener('click', ()=>{ Object.assign(P,{len:14,width:0.35,tip:1.1,base:1.2,curl:0.25,twist:0.2,bend:0.25,rib:0.15,serrA:0.05,serrF:12,double:true,stem:true}); for(const k of ['len','width','tip','base','curl','twist','bend','rib','serrA','serrF']) ui[k].value = P[k]; qs('#double').checked=true; qs('#stem').checked=true; syncLeafLabels(); buildLeaf(); });
qs('#randomize').addEventListener('click', ()=>{ function rnd(a,b){return a + Math.random()*(b-a)} function rndi(a,b){return (Math.random()*(b-a)+a)|0} P.len=rnd(8,28); P.width=rnd(0.2,0.65); P.tip=rnd(0.4,2.0); P.base=rnd(0.4,2.0); P.curl=rnd(0,1.1); P.twist=rnd(0,1.2); P.bend=rnd(-0.4,1.0); P.rib=rnd(0.05,0.35); P.serrA=rnd(0,0.2); P.serrF=rndi(0,24); for(const k of ['len','width','tip','base','curl','twist','bend','rib','serrA','serrF']) ui[k].value=P[k]; syncLeafLabels(); buildLeaf(); });
qs('#goTree').addEventListener('click', ()=>{ showScene(2); buildTree(); });

// --- Tree scene ---
const treeUI = { treeH: qs('#treeH'), crownR: qs('#crownR'), levels: qs('#levels'), spread: qs('#spread'), lean: qs('#lean'), leafCount: qs('#leafCount'), shape: qs('#shape') };
const treeLbl = { treeH: qs('#valTreeH'), crownR: qs('#valCrownR'), levels: qs('#valLevels'), spread: qs('#valSpread'), lean: qs('#valLean'), leafCount: qs('#valLeafCount'), shape: qs('#valShape') };
['treeH','crownR','levels','spread','lean','leafCount'].forEach(k=> treeUI[k].addEventListener('input', ()=>{ syncTreeLabels(); }));
treeUI.shape.addEventListener('change', syncTreeLabels);
function syncTreeLabels(){ treeLbl.treeH.textContent=treeUI.treeH.value+' m'; treeLbl.crownR.textContent=treeUI.crownR.value+' m'; treeLbl.levels.textContent=treeUI.levels.value; treeLbl.spread.textContent=treeUI.spread.value+'°'; treeLbl.lean.textContent=treeUI.lean.value+'°'; treeLbl.leafCount.textContent=treeUI.leafCount.value; treeLbl.shape.textContent=treeUI.shape.value; }
syncTreeLabels();

qs('#btnBuildTree')?.addEventListener('click', buildTree);
qs('#btnClearTree')?.addEventListener('click', clearTree);
qs('#btnFit')?.addEventListener('click', ()=>{ if(treeGroup) fitCameraTo(treeGroup, 2.0); });

function buildTree(){
  clearTree();
  if(!ground){
    const g = new THREE.PlaneGeometry(120,120,120,120); g.rotateX(-Math.PI/2);
    groundHeights = new Float32Array((121)*(121));
    ground = new THREE.Mesh(g, groundMat); scene.add(ground);
  }

  treeGroup = new THREE.Group(); scene.add(treeGroup);

  const H = parseFloat(treeUI.treeH.value);
  const levels = Math.min(100, parseInt(treeUI.levels.value)); // 安全上限
  const spread = parseFloat(treeUI.spread.value)*Math.PI/180;
  const lean = parseFloat(treeUI.lean.value)*Math.PI/180;

  const trunkMat = new THREE.MeshStandardMaterial({color:0x6b4f3a, roughness:0.95});
  const branchMat = new THREE.MeshStandardMaterial({color:0x6e5840, roughness:0.95});
  const branches = [];

  // iterative BFS with caps to avoid explosion
  const MAX_BRANCHES = 30000;           // 結構上限（安全）
  const LEN_DECAY = 0.75;               // 長度衰減
  const RAD_DECAY = 0.72;               // 半徑衰減
  const CHILD_PER_NODE = 2;             // 每節分叉數
  const PRUNE_BASE = 0.02;              // 基礎修剪概率（越高越稀疏）
  const PRUNE_GAIN = 0.008;             // 隨層遞增修剪
  const TIP_JITTER = 0.05;              // 末端擾動比例

  const queue = [];
  const base = new THREE.Vector3(0,0,0);
  const trunkDir = new THREE.Vector3(Math.sin(lean), Math.cos(lean), 0).normalize();
  const trunkLen = H*0.7;
  const trunkTop = base.clone().addScaledVector(trunkDir, trunkLen);
  queue.push({a:base, b:trunkTop, dir:trunkDir.clone(), len:H*0.5, r:0.12*H, lvl:1});

  while(queue.length && branches.length < MAX_BRANCHES){
    const cur = queue.shift();
    branches.push({a:cur.a.clone(), b:cur.b.clone(), r:cur.r});
    if(cur.lvl>=levels) continue;
    for(let c=0;c<CHILD_PER_NODE;c++){
      // prune probability increases with level
      const pruneP = PRUNE_BASE + PRUNE_GAIN*cur.lvl;
      if(Math.random()<pruneP) continue;
      const angA = (c===0? -1:1)*(spread*(0.6+0.4*Math.random()));
      const angY = Math.random()*Math.PI*2;
      const tilt = new THREE.Vector3(Math.cos(angY)*Math.sin(angA), Math.cos(angA), Math.sin(angY)*Math.sin(angA));
      const newDir = cur.dir.clone().multiplyScalar(0.35).add(tilt.multiplyScalar(0.65)).normalize();
      const newLen = cur.len * (LEN_DECAY + 0.03*Math.random());
      const nb = cur.b.clone().addScaledVector(newDir, newLen);
      // slight jitter near tips
      nb.x += (Math.random()-0.5)*newLen*TIP_JITTER;
      nb.z += (Math.random()-0.5)*newLen*TIP_JITTER;
      queue.push({a:cur.b.clone(), b:nb, dir:newDir, len:newLen, r:Math.max(0.012, cur.r*RAD_DECAY), lvl:cur.lvl+1});
      if(queue.length + branches.length >= MAX_BRANCHES) break;
    }
  }

  // build meshes
  const cyls = new THREE.Group();
  for(const s of branches){
    const v = new THREE.Vector3().subVectors(s.b, s.a);
    const len = v.length();
    const r1 = Math.max(0.012, s.r*0.6);
    const r2 = Math.max(0.010, s.r*0.5);
    const geo = new THREE.CylinderGeometry(r2, r1, len, 8);
    const mesh = new THREE.Mesh(geo, (len>H*0.45? trunkMat: branchMat));
    const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,1,0), v.clone().normalize());
    mesh.setRotationFromQuaternion(q);
    mesh.position.copy(s.a).addScaledVector(v,0.5);
    cyls.add(mesh);
  }
  treeGroup.add(cyls);

  // Leaves instancing
  const leafGeo = leafMesh.geometry.clone();
  const count = parseInt(treeUI.leafCount.value);
  const leaves = new THREE.InstancedMesh(leafGeo, matLeaf, count);
  leaves.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(count*3), 3, false);
  matLeaf.vertexColors = true;
  const dummy = new THREE.Object3D();
  const tipBias = (t)=> Math.pow(t, 4);
  for(let i=0;i<count;i++){
    const s = branches[(Math.random()*branches.length)|0];
    const t = 0.55 + 0.45*tipBias(Math.random());
    const pos = s.a.clone().lerp(s.b, t);
    const rad = (0.035 + 0.11*Math.random());
    const ang = Math.random()*Math.PI*2;
    pos.x += Math.cos(ang)*rad; pos.z += Math.sin(ang)*rad; pos.y += (Math.random()-0.5)*0.05;
    dummy.position.copy(pos);
    const dir = new THREE.Vector3().subVectors(s.b, s.a).normalize();
    const up = new THREE.Vector3(0,1,0);
    const side = new THREE.Vector3().crossVectors(dir, up).normalize();
    const leafUp = new THREE.Vector3().crossVectors(side, dir).normalize();
    const m = new THREE.Matrix4().lookAt(new THREE.Vector3(0,0,0), dir, leafUp).invert();
    dummy.rotation.setFromRotationMatrix(m);
    dummy.rotation.x += (Math.random()-0.5)*0.6;
    dummy.rotation.y += (Math.random()-0.5)*Math.PI;
    dummy.rotation.z += (Math.random()-0.5)*0.6;
    const sc = 0.7 + Math.random()*0.7; dummy.scale.setScalar(sc);
    dummy.updateMatrix();
    leaves.setMatrixAt(i, dummy.matrix);
    const c = new THREE.Color().setHSL(0.28 + 0.10*Math.random()*0.3, 0.75, 0.48);
    leaves.setColorAt(i, c);
  }
  leaves.instanceMatrix.needsUpdate = true;
  if(leaves.instanceColor) leaves.instanceColor.needsUpdate = true;
  treeGroup.add(leaves);
  leavesInst = leaves;

  fitCameraTo(treeGroup, 2.0);
  const info = `樹生成完成｜分枝節數：${branches.length}（安全上限 ${30000}），葉片：${count}`;
  diag(info, true);
}

function clearTree(){ if(treeGroup){ scene.remove(treeGroup); treeGroup.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose?.(); }); treeGroup=null; leavesInst=null; } }

// --- Fall scene (同 0.7.1，略) ---
const fallUI = { seasonRate: qs('#seasonRate'), fallRate: qs('#fallRate'), windAmp: qs('#windAmp'), turb: qs('#turb'), regrow: qs('#regrow'), start: qs('#btnStartFall'), stop: qs('#btnStopFall'), reset: qs('#btnResetFall'), maxActive: qs('#maxActive') };
const fallLbl = { seasonRate: qs('#valSeasonRate'), fallRate: qs('#valFallRate'), windAmp: qs('#valWind'), turb: qs('#valTurb'), regrow: qs('#valRegrow'), maxActive: qs('#valMaxActive') };
['seasonRate','fallRate','windAmp','turb','regrow','maxActive'].forEach(k=> fallUI[k].addEventListener('input', ()=>{ syncFallLabels(); }));
function syncFallLabels(){ fallLbl.seasonRate.textContent=fallUI.seasonRate.value+'×'; fallLbl.fallRate.textContent=fallUI.fallRate.value+'×'; fallLbl.windAmp.textContent=fallUI.windAmp.value; fallLbl.turb.textContent=fallUI.turb.value; fallLbl.regrow.textContent=fallUI.regrow.value+'×'; fallLbl.maxActive.textContent=fallUI.maxActive.value; }
syncFallLabels();
fallUI.start.addEventListener('click', ()=>{ showScene(3); prepareFall(); fallRunning=true; });
fallUI.stop.addEventListener('click', ()=>{ fallRunning=false; });
fallUI.reset.addEventListener('click', ()=>{ resetFallSeason(); });

function ensureFallArrays(n){
  leafVel = new Array(n);
  leafAngVel = new Array(n);
  leafPhase = new Float32Array(n);
  leafState = new Uint8Array(n);
  for(let i=0;i<n;i++){ leafVel[i]=new THREE.Vector3(); leafAngVel[i]=new THREE.Vector3(); leafPhase[i]=0; leafState[i]=0; }
  fallingList = [];
}

function prepareFall(){
  if(!leavesInst){ buildTree(); }
  const n = leavesInst.count;
  if(!ground){
    const g = new THREE.PlaneGeometry(120,120,120,120); g.rotateX(-Math.PI/2);
    groundHeights = new Float32Array((121)*(121));
    ground = new THREE.Mesh(g, groundMat); scene.add(ground);
  }
  ensureFallArrays(n);
  fallRunning=false; fallClock=0;
  fitCameraTo(treeGroup??leavesInst, 2.2);
}

function resetFallSeason(){ if(!leavesInst) return;
  const n=leavesInst.count; const dm = new THREE.Matrix4(); const pos=new THREE.Vector3(); const quat=new THREE.Quaternion(); const scl=new THREE.Vector3();
  for(let i=0;i<n;i++){
    leavesInst.getMatrixAt(i, dm); dm.decompose(pos, quat, scl);
    pos.y = Math.max(pos.y, 0.2);
    dm.compose(pos, quat, scl);
    leavesInst.setMatrixAt(i, dm);
    leafVel[i].set(0,0,0); leafAngVel[i].set(0,0,0);
    leafState[i]=0; leafPhase[i]=0;
    const c = new THREE.Color().setHSL(0.28, 0.75, 0.48);
    leavesInst.setColorAt(i, c);
  }
  leavesInst.instanceMatrix.needsUpdate=true;
  if(leavesInst.instanceColor) leavesInst.instanceColor.needsUpdate=true;
  fallClock=0; fallRunning=false; fallingList.length=0;
}

// noise & wind
function nrand(x,y,z){ const s=Math.sin(x*127.1+y*311.7+z*74.7)*43758.5453; return s-Math.floor(s); }
function smoothNoise(x,y,z){ const xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z); const xf=x-xi, yf=y-yi, zf=z-zi; function fade(t){return t*t*(3-2*t)}
  let n000=nrand(xi,yi,zi), n100=nrand(xi+1,yi,zi), n010=nrand(xi,yi+1,zi), n110=nrand(xi+1,yi+1,zi); let n001=nrand(xi,yi,zi+1), n101=nrand(xi+1,yi,zi+1), n011=nrand(xi,yi+1,zi+1), n111=nrand(xi+1,yi+1,zi+1);
  const u=fade(xf), v=fade(yf), w=fade(zf);
  const x00=THREE.MathUtils.lerp(n000,n100,u), x10=THREE.MathUtils.lerp(n010,n110,u), x01=THREE.MathUtils.lerp(n001,n101,u), x11=THREE.MathUtils.lerp(n011,n111,u);
  const y0=THREE.MathUtils.lerp(x00,x10,v), y1=THREE.MathUtils.lerp(x01,x11,v);
  return THREE.MathUtils.lerp(y0,y1,w);
}
function windAt(x,y,z){
  const A=parseFloat(fallUI.windAmp.value);
  const T=parseFloat(fallUI.turb.value);
  const dirRad=(windBaseDir)*Math.PI/180;
  const baseX=Math.cos(dirRad)*A, baseZ=Math.sin(dirRad)*A;
  const n1 = smoothNoise((x*0.25)+windTime*0.8, (z*0.25)-windTime*0.6, 0);
  const n2 = smoothNoise((-x*0.2)+windTime*0.5, (y*0.25)+windTime*0.6, 1);
  return new THREE.Vector3(baseX + T*(n1-0.5), 0.3*T*(n2-0.5), baseZ + T*(n2-0.5));
}

function stepFall(){
  if(!leavesInst) return;
  const n = leavesInst.count;
  const dm = new THREE.Matrix4(); const pos=new THREE.Vector3(); const quat=new THREE.Quaternion(); const eul=new THREE.Euler(); const scl=new THREE.Vector3();
  const seasonRate=parseFloat(fallUI.seasonRate.value);
  const fallRate=parseFloat(fallUI.fallRate.value);
  const regrow=parseFloat(fallUI.regrow.value);
  const maxActive = parseInt(fallUI.maxActive.value);

  fallClock += 0.016*seasonRate; windTime += 0.01;
  windBaseDir = (Math.sin(windTime*0.07)*15);

  // detach quota (cap active)
  const progress = Math.min(1, fallClock/30);
  let attachQuota = Math.min(200, 5 + (n*0.0005 + n*0.002*progress)|0);
  if(fallingList.length < maxActive){
    for(let trial=0; trial<attachQuota; trial++){
      const i = (Math.random()*n)|0;
      if(leafState[i]!==0) continue;
      leavesInst.getMatrixAt(i, dm); dm.decompose(pos, quat, scl);
      const heightFactor = THREE.MathUtils.clamp(pos.y / (parseFloat(treeUI.treeH.value)+0.01), 0, 1);
      const p = (0.0006 + 0.003*progress) * (0.4 + 0.8*heightFactor);
      if(Math.random() < p){
        leafState[i]=1; fallingList.push(i);
        const w = windAt(pos.x,pos.y,pos.z);
        leafVel[i].set((Math.random()-0.5)*0.05 + 0.003*w.x, -0.02, (Math.random()-0.5)*0.05 + 0.003*w.z);
        leafAngVel[i].set((Math.random()-0.5)*1.2, (Math.random()-0.5)*0.8, (Math.random()-0.5)*1.2);
      }
    }
  }

  // simulate active
  for(let k=fallingList.length-1; k>=0; k--){
    const i = fallingList[k];
    leavesInst.getMatrixAt(i, dm); dm.decompose(pos, quat, scl);
    leafPhase[i] = Math.min(2, leafPhase[i] + 0.0007*seasonRate);
    const c = (leafPhase[i]<1) ? new THREE.Color().setHSL(0.16 + 0.10*leafPhase[i], 0.7, 0.5 + 0.2*(1-leafPhase[i]))
                               : new THREE.Color().setHSL(0.04 + 0.02*(leafPhase[i]-1), 0.8, 0.55 - 0.1*(leafPhase[i]-1));
    leavesInst.setColorAt(i, c);

    const w = windAt(pos.x,pos.y,pos.z).multiplyScalar(0.002*fallRate);
    const L = P.len/100, W = (P.len*P.width)/100;
    const area = L*W;
    const curlK = 1 + P.curl*1.5;
    const Cd = 0.8*curlK;
    leafVel[i].y += (-0.0022*fallRate);
    const v2 = leafVel[i].lengthSq();
    const drag = leafVel[i].clone().multiplyScalar(-Cd*area*Math.max(0.0, v2));
    leafVel[i].add(drag);
    leafVel[i].x += w.x - 0.002*leafVel[i].x;
    leafVel[i].z += w.z - 0.002*leafVel[i].z;
    leafVel[i].y += w.y*0.3 - 0.001*leafVel[i].y;
    const zz = Math.sin(windTime*3 + i*0.37) * 0.005 * (1 + 0.6*P.width);
    leafVel[i].x += zz;

    eul.setFromQuaternion(quat);
    eul.x += (w.x*8 + leafAngVel[i].x)*0.01;
    eul.y += (w.y*6 + leafAngVel[i].y)*0.01;
    eul.z += (w.z*8 + leafAngVel[i].z)*0.01;
    quat.setFromEuler(eul);
    leafAngVel[i].multiplyScalar(0.98);
    leafAngVel[i].x += (Math.random()-0.5)*0.02*curlK;
    leafAngVel[i].z += (Math.random()-0.5)*0.02*curlK;

    pos.add(leafVel[i]);

    if(pos.y<=0){
      const gx = Math.round((pos.x/120+0.5)*120); const gz = Math.round((pos.z/120+0.5)*120);
      if(gx>=0 && gx<=120 && gz>=0 && gz<=120){
        const gi = gz*121 + gx;
        const h = groundHeights[gi] += 0.0015*(0.6 + 0.8*Math.random());
        pos.y = h;
      } else { pos.y = 0; }
      leafVel[i].set(0,0,0); leafState[i]=2;
      leafPhase[i] = Math.max(leafPhase[i], 1.6);
      fallingList[k] = fallingList[fallingList.length-1]; fallingList.pop();
    }

    dm.compose(pos, quat, scl); leavesInst.setMatrixAt(i, dm);
  }

  if(fallingList.length>0){
    leavesInst.instanceMatrix.needsUpdate=true;
    if(leavesInst.instanceColor) leavesInst.instanceColor.needsUpdate = true;
  }

  // regrow
  const landed = leafState.reduce((a,b)=> a+(b===2?1:0), 0);
  if(landed>n*0.8 && fallingList.length===0){
    const dm2 = new THREE.Matrix4(); const pos2=new THREE.Vector3(); const quat2=new THREE.Quaternion(); const scl2=new THREE.Vector3();
    let regenBatch = Math.min(500, n - landed);
    for(let i=0; i<n && regenBatch>0; i++){
      if(leafState[i]!==2) continue;
      leavesInst.getMatrixAt(i, dm2); dm2.decompose(pos2, quat2, scl2);
      pos2.y += 0.03*regrow;
      if(pos2.y > Math.random()*parseFloat(treeUI.treeH.value)){
        leafState[i]=0; leafPhase[i]=0;
        const c = new THREE.Color().setHSL(0.28, 0.75, 0.48);
        leavesInst.setColorAt(i, c);
        regenBatch--;
      }
      dm2.compose(pos2, quat2, scl2); leavesInst.setMatrixAt(i, dm2);
    }
    leavesInst.instanceMatrix.needsUpdate=true;
    if(leavesInst.instanceColor) leavesInst.instanceColor.needsUpdate = true;
  }
}

function fitCameraTo(obj, pad=1.8){
  if(!obj) return;
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(); const center = new THREE.Vector3();
  box.getSize(size); box.getCenter(center);
  const radius = Math.max(size.x, size.y, size.z)*0.5 || 0.1;
  const fov = camera.fov * Math.PI/180;
  const dist = (radius/Math.tan(fov/2)) * pad;
  const dir = new THREE.Vector3(1,0.6,1).normalize();
  camera.position.copy(center).addScaledVector(dir, dist);
  camera.near = Math.max(0.001, dist/1000);
  camera.far = dist*10 + 100;
  camera.updateProjectionMatrix();
  controls.target.copy(center);
  controls.update();
}

function resize(){
  const w = stage.clientWidth || stage.getBoundingClientRect().width || window.innerWidth;
  const h = stage.clientHeight || window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);

function loop(){
  controls.update();
  if(fallRunning && leavesInst){ stepFall(); }
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}

try{
  resize();
  function syncLeafInit(){ label.len.textContent=P.len.toFixed(1)+' cm'; label.width.textContent=P.width.toFixed(2); label.tip.textContent=P.tip.toFixed(2); label.base.textContent=P.base.toFixed(2); label.curl.textContent=P.curl.toFixed(2); label.twist.textContent=P.twist.toFixed(2); label.bend.textContent=P.bend.toFixed(2); label.rib.textContent=P.rib.toFixed(2)+' cm'; label.serrA.textContent=P.serrA.toFixed(3); label.serrF.textContent=String(P.serrF|0); }
  syncLeafInit(); buildLeaf();
  loop(); diag('v0.7.2-online 已啟動（分枝層數最高 100）', true);
}catch(err){ diag('初始化錯誤：'+err.message); }

</script>
</body>
</html>
