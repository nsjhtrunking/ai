<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê£íÁêÉË≥Ω‰∫ãÁ¥ÄÈåÑ - v0.2</title>
    <style>
        /* CSS for Bright UI and Layout */
        :root {
            --primary-color: #007bff; /* Blue */
            --secondary-color: #28a745; /* Green */
            --danger-color: #dc3545; /* Red */
            --background-color: #f8f9fa; /* Light Gray */
            --card-background: #ffffff; /* White */
            --text-color: #212529; /* Dark Gray */
            --border-color: #ced4da;
            --header-bg: #e9ecef;
            --shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            --inning-header-bg: #e2f0ff; /* Light Blue for Inning */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow: hidden; /* Important for drag/zoom */
        }

        /* Main Container for Zoom/Pan */
        #viewport {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }

        #content {
            transform-origin: 0 0;
            padding: 20px;
            box-sizing: border-box;
            min-width: 100%;
            min-height: 100%;
        }

        header {
            background-color: var(--header-bg);
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
        }

        h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.5rem;
        }

        main {
            padding-top: 80px; /* Offset for fixed header */
        }

        .card {
            background-color: var(--card-background);
            border-radius: 8px;
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="text"], select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.9rem;
        }

        /* Lineup Table Styles */
        #lineupTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        #lineupTable th, #lineupTable td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: center;
            font-size: 0.9rem;
        }

        #lineupTable th {
            background-color: var(--primary-color);
            color: white;
            position: sticky;
            top: 60px; /* Below header */
            z-index: 50;
        }
        
        #lineupTable .inning-col {
            min-width: 100px; /* Ensure enough space for buttons */
        }

        /* Result Button Styles */
        .result-btn-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .result-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 40px; /* Minimum width for small screens */
            transition: background-color 0.1s;
        }

        .result-btn.out-result {
            background-color: var(--danger-color);
        }

        .result-btn.hit-result {
            background-color: var(--primary-color);
        }
        
        .result-btn:hover {
            opacity: 0.8;
        }

        /* Current Inning Header */
        .inning-header {
            background-color: var(--inning-header-bg);
            padding: 10px;
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--primary-color);
            text-align: left;
        }

        /* Log Section */
        #log-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }
        
        /* Interactive Drag and Zoom */
        @media (min-width: 768px) {
            main {
                max-width: 1200px;
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>‚öæ Ê£íÁêÉË≥Ω‰∫ãÁ¥ÄÈåÑÁ∂≤È†Å v0.2</h1>
    </header>

    <div id="viewport">
        <div id="content">
            <main>
                <div class="card">
                    <h2>üìù ÊîªÊñπÊ£íÊ¨°ËàáÂÆàÂÇô‰ΩçÁΩÆ</h2>
                    <table id="lineupInputTable">
                        <thead>
                            <tr>
                                <th>Ê£íÊ¨°</th>
                                <th>ÂßìÂêç</th>
                                <th>ÂÆàÂÇô‰ΩçÁΩÆ</th>
                            </tr>
                        </thead>
                        <tbody id="lineupBody">
                            </tbody>
                    </table>
                </div>

                <div class="card">
                    <h2>üìä ÊØîË≥ΩÁ¥ÄÈåÑË°®</h2>
                    <table id="lineupTable">
                        <thead>
                            <tr>
                                <th style="min-width: 60px;">Ê£íÊ¨°</th>
                                <th style="min-width: 100px;">ÂßìÂêç / ÂÆàÂÇô</th>
                                </tr>
                        </thead>
                        <tbody id="recordBody">
                            </tbody>
                    </table>

                    <button class="result-btn" style="background-color: #007bff; margin-top: 15px;" onclick="endInning()">
                        Ê≠§Â±ÄÊîªÊìäÁµêÊùü (Êé®ÈÄ≤‰∏ã‰∏ÄÂ±Ä)
                    </button>
                </div>

                <div class="card">
                    <h2>üìú Á¥ÄÈåÑ Log</h2>
                    <div id="log-container">Â∞öÊú™ÊúâÊîªÊìäÁ¥ÄÈåÑ...</div>
                </div>
                
                <p style="text-align: center; margin-top: 30px; color: #6c757d;">ÊèêÁ§∫ÔºöÈªûÊìäÊàñÊãñÊõ≥Ê≠§È†ÅÈù¢‰ª•ÁßªÂãïÔºåÈõªËÖ¶ÂèØ‰ΩøÁî®ÊªæËº™Á∏ÆÊîæ„ÄÇ</p>
            </main>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const MAX_BATTERS = 10;
        const DEFENSIVE_POSITIONS = [
            'P', 'C', '1B', '2B', '3B', 'SS', 'LF', 'CF', 'RF', 'DH', 'EH'
        ];
        const AT_BAT_RESULTS = {
            O: { label: 'O', type: 'out', className: 'out-result' },
            FO: { label: 'FO', type: 'out', className: 'out-result' },
            K: { label: 'K', type: 'out', className: 'out-result' },
            '1B': { label: '1B', type: 'hit', className: 'hit-result' },
            '1B(1)': { label: '1B(1)', type: 'hit', runs: 1, className: 'hit-result' },
            '1B(2)': { label: '1B(2)', type: 'hit', runs: 2, className: 'hit-result' },
            '1B(3)': { label: '1B(3)', type: 'hit', runs: 3, className: 'hit-result' },
            '2B': { label: '2B', type: 'hit', className: 'hit-result' },
            '2B(1)': { label: '2B(1)', type: 'hit', runs: 1, className: 'hit-result' },
            '2B(2)': { label: '2B(2)', type: 'hit', runs: 2, className: 'hit-result' },
            '2B(3)': { label: '2B(3)', type: 'hit', runs: 3, className: 'hit-result' },
            HR: { label: 'HR', type: 'hit', runs: 4, className: 'hit-result' }, // Max 4 runs for HR
            BB: { label: 'BB', type: 'base', className: '' },
            'FC(1)': { label: 'FC(1)', type: 'out', runs: 1, className: 'out-result' }, // Fielder's Choice w/ 1 run
            'FC(2)': { label: 'FC(2)', type: 'out', runs: 2, className: 'out-result' }, 
            'FC(3)': { label: 'FC(3)', type: 'out', runs: 3, className: 'out-result' },
        };
        const AB_RESULT_KEYS = Object.keys(AT_BAT_RESULTS);

        // --- Data Store ---
        let lineup = []; // { batterId: number, name: string, position: string }
        let currentInning = 1;
        let gameRecord = {}; // { batterId: { 1: '1B(1)', 2: 'K', ... }, ... }
        let gameLog = []; // [{ inning: number, batterId: number, result: string, name: string, position: string }]

        // --- DOM Elements ---
        const lineupBody = document.getElementById('lineupBody');
        const lineupTableHead = document.getElementById('lineupTable').querySelector('thead tr');
        const recordBody = document.getElementById('recordBody');
        const logContainer = document.getElementById('log-container');


        // --- Initialization ---

        function initLineupInput() {
            for (let i = 1; i <= MAX_BATTERS; i++) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${i}</td>
                    <td><input type="text" id="name-${i}" placeholder="ÁêÉÂì°ÂßìÂêç" onchange="updateLineup(${i})"></td>
                    <td><select id="pos-${i}" onchange="updateLineup(${i})">${generatePositionOptions()}</select></td>
                `;
                lineupBody.appendChild(tr);
                lineup.push({ batterId: i, name: '', position: DEFENSIVE_POSITIONS[0] });
                gameRecord[i] = {};
            }
        }

        function generatePositionOptions() {
            return DEFENSIVE_POSITIONS.map(pos => `<option value="${pos}">${pos}</option>`).join('');
        }

        // --- Lineup Management ---

        function updateLineup(batterId) {
            const nameInput = document.getElementById(`name-${batterId}`);
            const posSelect = document.getElementById(`pos-${batterId}`);
            
            const playerIndex = batterId - 1;
            lineup[playerIndex].name = nameInput.value.trim();
            lineup[playerIndex].position = posSelect.value;
            
            renderRecordTable();
        }

        // --- Record Table Rendering ---

        function renderInningHeader() {
            // Remove all existing inning columns
            const existingInnings = lineupTableHead.querySelectorAll('.inning-header-col');
            existingInnings.forEach(col => col.remove());

            // Add new inning columns
            for (let i = 1; i <= currentInning; i++) {
                const th = document.createElement('th');
                th.className = 'inning-header-col';
                th.textContent = `${i} Â±Ä`;
                lineupTableHead.appendChild(th);
            }
        }

        function renderRecordTable() {
            recordBody.innerHTML = '';
            
            lineup.forEach(player => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${player.batterId}</td>
                    <td>${player.name || '(Êú™Ëº∏ÂÖ•)'} / ${player.position}</td>
                `;

                for (let i = 1; i <= currentInning; i++) {
                    const td = document.createElement('td');
                    td.className = 'inning-col';

                    const recordedResult = gameRecord[player.batterId][i];

                    if (i === currentInning) {
                        // Current Inning: show buttons
                        if (recordedResult) {
                            // Show recorded result
                             td.innerHTML = `<span style="font-weight: bold; color: ${AT_BAT_RESULTS[recordedResult].type === 'out' ? var(--danger-color) : var(--primary-color)};">${recordedResult}</span>`;
                        } else {
                            // Show input buttons
                            td.innerHTML = generateResultButtons(player.batterId, i);
                        }
                    } else {
                        // Past Innings: show recorded result or '-'
                        td.innerHTML = recordedResult 
                            ? `<span style="font-weight: bold; color: ${AT_BAT_RESULTS[recordedResult].type === 'out' ? '#6c757d' : '#28a745'};">${recordedResult}</span>`
                            : '-';
                    }
                    tr.appendChild(td);
                }
                recordBody.appendChild(tr);
            });
            
            // Re-render headers (in case currentInning changed)
            renderInningHeader();
        }

        function generateResultButtons(batterId, inning) {
            let html = '<div class="result-btn-container">';
            AB_RESULT_KEYS.forEach(result => {
                const resultInfo = AT_BAT_RESULTS[result];
                const btnClass = resultInfo.className;
                html += `<button class="result-btn ${btnClass}" onclick="recordAtBat(${batterId}, ${inning}, '${result}')">${result}</button>`;
            });
            html += '</div>';
            return html;
        }

        // --- Game Logic ---

        function recordAtBat(batterId, inning, result) {
            if (inning !== currentInning) return; // Only allow record on current inning

            const player = lineup.find(p => p.batterId === batterId);
            if (!player || !player.name) {
                alert('Ë´ãÂÖàËº∏ÂÖ•Ë©≤Ê£íÊ¨°ÁêÉÂì°ÂßìÂêçÔºÅ');
                return;
            }
            
            // 1. Record Result
            gameRecord[batterId][inning] = result;
            
            // 2. Update Log
            gameLog.push({
                inning: inning,
                batterId: batterId,
                name: player.name,
                position: player.position,
                result: result,
                runs: AT_BAT_RESULTS[result].runs || 0
            });
            
            // 3. Re-render Table and Log
            renderRecordTable();
            renderLog();
            
            console.log(`Inning ${inning}, Batter ${batterId} (${player.name}): ${result}`);
        }

        function endInning() {
            // Check if all batters have results in the current inning
            const allResultsRecorded = lineup.every(player => gameRecord[player.batterId][currentInning]);

            if (!allResultsRecorded) {
                const confirmSkip = confirm('Êú¨Â±Ä‰ªçÊúâÁêÉÂì°Êú™Ë®òÈåÑÊîªÊìäÁµêÊûúÔºåÁ¢∫ÂÆöË¶ÅÁµêÊùüÊ≠§Â±Ä‰∏¶Êé®ÈÄ≤Âà∞‰∏ã‰∏ÄÂ±ÄÂóéÔºü');
                if (!confirmSkip) {
                    return;
                }
            }

            currentInning++;
            
            // Ensure new inning column is added for all players
            lineup.forEach(player => {
                if (!gameRecord[player.batterId][currentInning]) {
                    gameRecord[player.batterId][currentInning] = null;
                }
            });

            renderRecordTable();
            // Scroll to the right to see the new inning column (if needed)
            document.getElementById('lineupTable').scrollLeft = document.getElementById('lineupTable').scrollWidth;
            console.log(`--- Inning ${currentInning - 1} Ended. Starting Inning ${currentInning}. ---`);
        }

        function renderLog() {
            if (gameLog.length === 0) {
                logContainer.textContent = 'Â∞öÊú™ÊúâÊîªÊìäÁ¥ÄÈåÑ...';
                return;
            }

            let logText = '';
            gameLog.forEach(log => {
                const runsText = log.runs > 0 ? ` (ÂæóÂàÜ: ${log.runs} ÂàÜ)` : '';
                logText += `[${log.inning}Â±Ä] Ê£íÊ¨°${log.batterId} (${log.name}/${log.position}): ${log.result}${runsText}\n`;
            });
            logContainer.textContent = logText;
            // Auto-scroll to bottom of log
            logContainer.scrollTop = logContainer.scrollHeight;
        }


        // --- Interactive Drag and Zoom Functionality (From v0.1) ---

        const viewport = document.getElementById('viewport');
        const content = document.getElementById('content');
        let scale = 1;
        let panX = 0;
        let panY = 0;

        function applyTransform() {
            content.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        // --- Mouse/Desktop Handling ---
        let isDragging = false;
        let startX, startY;
        let lastPanX, lastPanY;

        viewport.addEventListener('mousedown', (e) => {
            // Ignore drag start on interactive elements
            if (e.target.closest('input, button, select, th')) return;
            
            isDragging = true;
            viewport.style.cursor = 'grabbing';
            startX = e.clientX;
            startY = e.clientY;
            lastPanX = panX;
            lastPanY = panY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            panX = lastPanX + dx;
            panY = lastPanY + dy;
            applyTransform();
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            viewport.style.cursor = 'grab';
        });

        // Mouse Wheel Zoom
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY * -0.01;
            const newScale = Math.min(Math.max(0.5, scale + delta), 3.0);
            
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const scaleFactor = newScale / scale;
            panX = mouseX - (mouseX - panX) * scaleFactor;
            panY = mouseY - (mouseY - panY) * scaleFactor;

            scale = newScale;
            applyTransform();
        });

        // --- Touch/Mobile Handling ---
        let touchStartDist = -1;
        let touchStartX, touchStartY;
        let lastPanXTouch, lastPanYTouch;

        viewport.addEventListener('touchstart', (e) => {
            // Check if touch starts on interactive element
            if (e.target.closest('input, button, select, th')) return;

            if (e.touches.length === 1) {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastPanXTouch = panX;
                lastPanYTouch = panY;
            } else if (e.touches.length === 2) {
                e.preventDefault();
                touchStartDist = getDistance(e.touches[0], e.touches[1]);
                touchStartX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                touchStartY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                lastPanXTouch = panX;
                lastPanYTouch = panY;
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && touchStartDist > 0) {
                e.preventDefault();
                const newDist = getDistance(e.touches[0], e.touches[1]);
                const scaleRatio = newDist / touchStartDist;
                const newScale = Math.min(Math.max(0.5, scale * scaleRatio), 3.0);

                const touchMidX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const touchMidY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                
                const dx = touchMidX - touchStartX;
                const dy = touchMidY - touchStartY;
                
                const rect = viewport.getBoundingClientRect();
                const viewportMidX = touchMidX - rect.left;
                const viewportMidY = touchMidY - rect.top;

                const scaleFactor = newScale / scale;
                panX = viewportMidX - (viewportMidX - lastPanXTouch) * scaleFactor + dx;
                panY = viewportMidY - (viewportMidY - lastPanYTouch) * scaleFactor + dy;
                
                scale = newScale;
                touchStartDist = newDist;
                lastPanXTouch = panX;
                lastPanYTouch = panY;
                touchStartX = touchMidX;
                touchStartY = touchMidY;
                
                applyTransform();

            } else if (e.touches.length === 1 && touchStartDist < 0) {
                if (e.target.closest('input, button, select, th')) return;
                e.preventDefault();

                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                
                panX = lastPanXTouch + dx;
                panY = lastPanYTouch + dy;

                applyTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            touchStartDist = -1;
        });

        function getDistance(t1, t2) {
            return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
        }

        // --- Initial Load ---
        window.onload = function() {
            initLineupInput();
            renderRecordTable();
            applyTransform(); 
        }

    </script>
</body>
</html>